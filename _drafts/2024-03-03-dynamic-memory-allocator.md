---
layout: post
title: "[C] 힙(heap)한 할당기(동적 할당기)"
date: 2024-03-03 21:37 +0900
description: malloc-lab 구현기
category: [프로그래밍, Implement]
tags: [c, 명시적 할당기, malloc, heap]
---

C++이나 자바에서는 new 키워드를 통해 객체를 생성한다. 파이썬에선 별다른 키워드 없이 일반 함수 호출과 동일하게 객체를 생성하게 될 것이다. 이 때 우리는 별다른 메모리를 할당해주지 않았는데, 이는 **가비지 컬렉터**가 존재하기 때문이다. 가비지 컬렉터는 개발자를 대신하여 메모리 할당과 해제를 하기 때문에 개발자가 직접적인 메모리 관리 책임을 벗어날 수 있게 한다.

하지만 C에서는 메모리 할당과 해제를 명시적으로 해주어야하며, 이를 위해 **명시적 할당기**가 존재한다. malloc과 free 같은 함수가 이에 속한다. 이번 글에서는 실제로 heap 영역만을 다루는 명시적 할당기를 구현해보고, malloc은 어떤 식으로 구현되어 있을 지 알아본다.

## 개념들을 되짚는 것으로 내용 변경하자!

# 개념
---
## 메모리 블럭

우선, 할당기를 구현하기 전에 알아둬야 할 개념을 정리하고 가야겠다.
메모리는 1 byte씩 나눠져 주소를 가지며, 일렬로 늘어져 있는 형태이다. 하지만 그렇다고 cpu가 연산시에 메모리에 접근하여 1 byte씩 가져오기에는 너무나 작은 단위이며 너무 빈번한 접근을 해야할 것이다. 따라서 메모리는 의미있는 단위로 다뤄져야 하며, 의미에 대한 기준은 cpu가 한번의 연산시 가져오는 최소 메모리의 크기이다.

이 단위는 cpu가 어떤 메모리 환경에 놓여져있냐에 따라 달라진다. 만약 32 bit 메모리 주소 체계를 가진다면, cpu가 메모리에서 가져오는 최소 블럭의 크기는 4 byte이며, 64 bit 일 때는 8 byte이다. 이러한 단위를 **word**라고 부른다.

그리하여, 동적 할당기에서 메모리는 word를 최소 단위로 가지며, 메모리 블록의 집합으로 보고 관리한다.

> 이번 구현 환경은 ubuntu에서 x86-32 환경으로 진행될 것이다.

## 단편화
메모리에서 빈 공간 또는 데이터가 여러 조각으로 나뉘는 현상을 말하며, 메모리 낭비와 읽기 쓰기 수행속도를 늦추는 문제를 발생시킨다.
이러한 단편화에는 두가지 종류가 있다.

>내부 단편화
: 할당된 블록이 데이터 자체보다 클 때 발생 (= 블록에 남는 공간이 발생). 내부 단편화는 메모리 낭비양을 쉽게 계산할 수 있다. 지정한 블록크기에 데이터 크기를 뺀 값을 다 더하면 되기 때문. 사용하지 않는 메모리가 **블록 내**에 있기 때문에 **“내부”** 라고 지칭. 

>외부 단편화
: 여유공간이 여러 조각으로 나눠져서 발생. 메모리가 남아있지만, 조금씩 분할되어 남아있어 새로운 메모리 할당이 불가능해진다. 이로써 메모리 낭비가 발생한다. 사용하지 않는 메모리가 할당된 메모리 블럭 **“외부”**에 있기 때문에 외부 단편화라고 한다.

외부 단편화는 측정하기 어렵다. 미래의 요청에 의존하기 때문이다. 쉽게 말해, 지금 4 워드를 할당했다고 한들, 나중에 할당될 블럭이 4 워드임을 보장할 수 없다는 것이다. 이렇다보니 외부 단편화에 있어서는 휴리스틱을 적용하여 작은 사이즈가 많은 블럭보단, 크기가 크고 적은 수의 블럭을 유지하려 한다.

# 구현

## 요구사항과 목표
구현에 앞서 요구사항과 할당기의 목표를 정해보자면 다음과 같다.

### 요구사항
1. **임의의 순서로 요청을 처리해야한다** : 할당기가 할당과 해제의 순서에 관여해선 안된다.
2. **요청에 즉시 응답하기**: 요청을 버퍼에 담아두고 한꺼번에 처리하거나 정렬하는 행위를 해선 안된다.
3. **힙만 사용하기**: 확장성을 가져야하기에 힙에 저장된다.
4. **블록 정렬하기**: 어떠한 데이터 타입이라도 저장될 수 있도록 블록을 구성해야한다.
5. **할당된 블록 수정하지 않기**: 사용 가능한 블록만 수정해야하며, 이미 할당된 블록을 옮기거나 압축하는 것을 하면 안된다.

### 목표
1. **처리량 극대화**
    - 처리량은 단위 시간당 완료된 요청의 갯수를 말한다. *ex) malloc 500, free 500번을 1초에 완료했다면 처리량은 1000이다.*
2. **메모리 이용도 최대화**
    - 메모리 이용도는 할당된 블럭 크기에 힙의 크기를 나눈 값 중 가장 큰 값을 취한다.

처리량을 극대화 시키기 위해서 메모리 이용도를 희생시킬 수 있다. 그에 반대도 마찬가지이므로, 이 둘 사이의 균형을 잡는 것이 중요하다.

## 묵시적 리스트 (Implicit list)

- first fit
- next fit
- best fit

- 목표에 따르는 문제점

- 처리량과 함께 메모리 이용도 증가 목표

## 명시적 리스트 (Explicit list)
---
- LIFO(최근 반환) + next fit
- sort + best fit

# 추가 개선 방안 (분리 가용 리스트(Segregated list), realloc)
---
- size 별 클래스를 추가로 두고 관리
- 실제 malloc에서도 사용되는 방법

# 마무리
---
- 메모리 할당 정책들을 구현해보고 각 정책들의 성능과 한계를 알아 보았다.  
- 목표(처리량, 메모리 이용도)에 따라 다른 검색 방식과 정책을 선택할 수 있다.
- 메모리 블럭이 최소 블럭 단위로 정렬되있는 것을 알았다.  

(구현된 레포지토리 링크)

## 참고자료
- malloc-lab(원본 레포지토리)