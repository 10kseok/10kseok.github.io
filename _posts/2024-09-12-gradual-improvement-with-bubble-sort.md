---
layout: post
title: "[WRITING] 버블 정렬로 해보는 점진적 개선: 버블 정렬에서 칵테일 정렬까지"
date: 2024-09-12 23:43 +0900
description: 버블 소트로 해보는 점진적 개선
category: [컴퓨터과학, Algorithm]
tags: [버블 소트, 버블 정렬, 점진적 개선, python]
---

버블 정렬은 가장 간단한 정렬 알고리즘으로 꼽을 수 있다. 구현이 매우 간단하여 급하게 정렬 알고리즘이 필요할 때 요긴하게 쓰인다. 하지만, 시간 복잡도에서 최악의 경우 O(n^2)이 나오기 때문에 대용량 데이터에서 빠른 성능을 기대하기는 어렵다. 그럼에도 불구하고, 버블 정렬도 몇가지를 개선하면 나름의 성능을 끌어올릴 수가 있다.  

이것을 주제로 발표를 한적도 있었는데, 이 때 무슨 자신감이였는지 화이트보드 코딩에 도전했었다. 결과는 역시나 중간에 머리가 새까매져 단체 일시정지가 있었다. 어찌저찌 잘 마무리는 했으나 겸손이 주입될 수 있었던 경험이였다. 그때의 경험을 희석시키고자 글로써 정리해보려고 한다.

## 정렬
---
정렬의 핵심 연산에는 교환, 선택, 삽입이 있다. 대부분의 정렬 알고리즘은 이 세가지를 응용해서 만들어졌다. 교환은 두 원소의 위치를 서로 변경하는 것, 선택은 특정 기준의 원소 하나를 골라내는 것, 삽입은 특정 위치에 원소를 집어넣고 나머지를 밀어내는 것을 말한다. 정렬 알고리즘에는 버블 정렬, 셸 정렬, 퀵 정렬, 병합 정렬 등 많은 알고리즘이 존재하며 각 정렬 알고리즘마다 주로 사용하는 연산이 있다. 그 중 버블 정렬에서는 **교환** 연산이 주로 쓰인다.

> **정렬은 왜 하는가?**  
정렬은 효율적인 조회를 위해 필요한 동작이다. 정렬을 통해 최소, 최대값을 찾거나 특정 값을 빠르게 조회할 수 있다. 특히나, 이분 탐색에서는 특정 값을 조회하기 위해서 정렬된 것이 전제 조건이다.

단순한 정렬 알고리즘에는 버블, 삽입, 선택 정렬이 있는데, 이들은 시간 복잡도는 같으나 삽입과 교환 연산에서 차이가 있다. 인접한 두 요소만 가지고 비교하여 교환하면 버블, 가장 작은 요소를 찾아서 앞에서부터 교환하면 선택, 요소를 적절한 위치에 끼워넣으면 삽입 정렬이다.

이번에 다룰 정렬은 앞에서 언급했던 버블 정렬이다. 이제 버블 정렬에 대해서 자세히 알아보자.

## 버블 정렬
---
### 기본 동작  
버블 정렬의 기본 동작(오름차순 기준)은 다음과 같다.
1. 리스트의 처음부터 끝까지 이동하면서 인접한 두 요소를 비교한다.
2. 만약 앞의 요소가 뒤의 요소보다 크다면, 두 요소의 위치를 교환한다.
3. 이 과정을 리스트의 끝까지 반복하면 가장 큰 요소가 리스트의 끝으로 이동하게 된다.
4. 이제 리스트의 끝에 있는 가장 큰 요소를 제외하고, 나머지 요소들에 대해 같은 과정을 반복한다.
5. 이 과정을 리스트의 모든 요소가 정렬될 때(n-1번)까지 반복한다.

```python
def bubble_sort(a_list):
    n = len(a_list)
    for i in range(n - 1):
        for j in range(n - 1 - i):
            if a_list[j] > a_list[j + 1]:
                a_list[j], a_list[j + 1] = a_list[j + 1], a_list[j] 
```

### 성능 측정
TODO  
[x] 비교, 교환 횟수 측정  
[x] 정렬이 잘 되는 지 확인  
[x] 리스트의 사이즈가 클 때 시간 확인  

## 1차 개선
---

## 2차 개선
---

## (3차 개선) 칵테일 정렬
---

## 마무리
---

