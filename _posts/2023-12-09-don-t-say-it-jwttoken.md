---
layout: post
title: JWT 구현시 JWTToken 이라고 하지 말자.
date: 2023-12-09 20:05 +0900
description: 쿡슝 프로젝트에서 인증을 맡으며..
category: [컴퓨터과학, knowledge]
tags: [JWT, 인증, 스케일이슈]
---

우리가 웹사이트를 이용할 때 가장 먼저 하는 것은 로그인이다.
로그인한 뒤 사이트에서 제공하는 서비스를 이용한다. 
아이디, 비밀번호만 일치시키면 되니까 매우 간단한 기능으로 보인다. 이번 글은 실제로도 그럴지 생각해보는 글이다.

## 인증 방식
---  
아이디, 비밀번호를 이제부턴 '자격증명'이라고 하자.
우린 자격증명을 전송하여 일치하면 사이트로부터 회원임을 인증 받는다. 인증을 통해 내가 이 사이트에 회원이고 내가 **나**임을 알린다.

인증 방식에는 여러가지가 존재하는데 그 중 Basic 인증은 Base64로 인코딩한 자격증명을 전송한다. ex) Authorization : Basic 아이디:비밀번호   

서버에서는 전달받은 자격증명을 DB에 접속하여 일치하는 지 확인하고 그에 맞는 응답을 내려보낸다.
여기서 주의해야할 점은 Basic 인증은 **자격증명을 그대로 노출**시킨다는 점이다. Base64 인코딩은 안전하게 전송하기 위한 수단일 뿐, 보안은 적용되어 있지 않다. 따라서 이러한 상황에서는 HTTPS 통신이 필수적이다.

![HTTP 인증](https://developer.mozilla.org/ko/docs/Web/HTTP/Authentication/http-auth-sequence-diagram.png){: style="background-color:white" width="972" height="589" }
_출처 : <https://developer.mozilla.org/ko/docs/Web/HTTP/Authentication>_

HTTP는 무상태성을 가지므로, 현재의 요청은 과거의 요청과는 상관없이 독립적이다.  
이는 서비스 이용시 매 요청마다 자격증명을 보내야한다는 것을 뜻한다.  
전송받은 자격증명은 DB와 연결하여 일치여부를 확인하게 되는데, 이는 인증 요청이 늘어날 때 DB에 부하를 주며,
이 과정으로 인해 인증이 **단일 장애 지점**(SPOF)이 될 수 있다.

이를 해결하기 위한 방법으로 **토큰 기반 인증**이 있다.  
자격증명을 토큰으로 대체하여 DB 접속 없이 서버가 가진 토큰과 클라이언트에서 보내온 토큰과 비교하여 인증을 진행한다.
이러한 인증에 쓰이는 토큰으로는 SAML, SWT, JWT 등이 있다.     
- **SAML**는 인증 요청과 응답, 메타데이터 등으로 구성되어있는 XML 토큰이다.  
- **SWT**(Simple Web Token)은 키와 값 쌍으로 이뤄져있고 대칭키 알고리즘으로만 서명되는 가장 단순한 토큰이다.  
- **JWT**(Json Web Token)은 JSON 구조를 가지며 대칭키 또는 비대칭키 알고리즘으로도 서명될 수 있는 토큰이다.

## 스케일 이슈
---
토큰 기반 인증은 서버가 상태를 가진다는 점에서 세션 방식과 차이가 없다.   
토큰 대체를 통해 자격증명의 노출과 DB 접근은 줄였지만 스케일 이슈에는 대응하지 못하는 문제점이 남아있다.
이를 해결하기 위해서 전자 서명이 된 토큰을 사용할 수 있다. 사실 위에 언급한 토큰들은 모두 전자 서명이 가능한 토큰들이다.   
이러한 토큰들은 서명을 통해 변조와 유효성을 검증한다. 

만약 마이크로서비스 아키텍처이고 REST API를 제공한다면, 인증을 구성하는데 있어 SWT나 JWT를 고려할 수 있다. 
또한 암호화 선택폭도 넓고, 대부분의 프로그래밍 언어에서 라이브러리를 제공하므로 이를 기반으로 JWT가 우선될 것이다.

JWT는 `{헤더}.{페이로드}.{시그니처}`로 이뤄져있다.   
**헤더**에는 토큰의 타입과 알고리즘에 관한 정보가 담기며,   
**페이로드**에는 실제 전송하는 데이터를,   
**시그니처**에는 둘 다 Base64로 인코딩된 헤더와 페이로드를 비밀번호(secret)와 함께 해쉬 함수를 적용시킨 값이 들어간다. 이 때 해쉬 함수는 헤더에 지정된 알고리즘으로 정해진다.
```javascript
// 헤더
{
  "alg": "HS256",
  "typ": "JWT"
}
// ------------------
// 페이로드
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
// ------------------
```
위와 같은 JWT는 Base64로 인코딩되어 아래와 같이 변하게 된다.
![생성된 JWT](https://cdn2.auth0.com/content/jwt/encoded-jwt4.png){: style="background-color:white" width="972" height="589" }
_생성된 JWT | 출처 : <https://jwt.io/introduction/>_

만약 변조된 토큰이나, 다른 서버에서 발급된 토큰이 들어온다면 해당 토큰을 비밀번호 값으로 해싱해보면 값이 다르기 때문에 쉽게 걸러낼 수 있다.
이로써 토큰 생성 비밀번호(secret)만 알면 서버가 토큰에 대한 정보를 가지고 있을 필요없이 인증 처리가 가능해지므로, 스케일 이슈를 해결할 수 있다.

## 보안 이슈
---
토큰을 사용자가 잘 보관한다면 스케일 이슈도 해결되고 별다른 문제가 없어보인다. 하지만 토큰이 누군가에게 탈취되었다면 어떻게 될까??
토큰이 결국 자격증명을 대체함으로 결국 탈취자가 사용자의 모든 권한을 이용할 수 있을 것이다.

그렇다면 이 토큰을 제한시간을 두는 방법을 쓴다고 가정하자. 그렇다면 탈취자가 토큰을 탈취한다하더라도 사용에 있어 제한되게 된다.
좋다. 그런데 제한시간을 두면 사용자 또한 불편함을 겪을 것이다. 

# 참고자료
- 스프링 시큐리티 인 액션, 로렌티우 스필카
- React.js, 스프링 부트, AWS로 배우는 웹 개발 101 , 김다정
- [HTTP에서 Basic 인증 스펙](https://datatracker.ietf.org/doc/html/rfc7617)  
- [JWT 공식문서](https://jwt.io/introduction/)      
- [SAML(Security Assertion Markup Language)이란?](https://learn.microsoft.com/en-us/entra/architecture/auth-saml)