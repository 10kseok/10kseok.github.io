---
layout: post
title: JWT 구현시 JWTToken 이라고 하지 말자.
date: 2023-12-09 20:05 +0900
description: 쿡슝 프로젝트에서 인증을 맡으며..
category: [컴퓨터과학, knowledge]
tags: [JWT, 인증, 스케일이슈, 보안이슈, MSA, REST]
---

NHN 아카데미 프로젝트 과정에서 음식 배달 플랫폼을 개발했었는데, 나는 여기서 회원 도메인과 인증을 맡아서 구현했었다.  
여러 서비스가 나눠져서 구성된 MSA 형태를 가졌었는데, DB는 나누지 않아 완전한 MSA는 아니였다.  
요구사항이 주어지고 구현하는 형태였었었는데 구현중에 기술에 대한 의문이 들곤 했었다. 
그래서 이참에 그때한 학습한 내용들을 정리해보려한다.

## 인증 방식
---  
우선, **인증은 사용자 신원을 확인하는 과정**이다. 사이트에 내가 **회원**이자 **나**임을 알리는 과정이라고 볼 수 있다.  
HTTP로 인증하는 방식에는 여러 종류가 있었는데, 그 중 가장 간단한 Basic 인증이 있다.

Basic 인증은 아이디, 비밀번호를 **헤더**에 담아 `Authorization : Basic 아이디:비밀번호`와 같은 형식으로 서버에 전송한다.
아이디, 비밀번호를 이제부턴 '자격증명'이라고 하면, 이 자격증명이 Base64로 인코딩되어 헤더에 담겨 보내지는 것이다.

이 과정에서 서버는 전송받은 자격증명과 DB에 정보와 일치하면 사이트로부터 회원임을 인증 받는다.
여기서 주의해야할 점은 Basic 인증은 **자격증명을 그대로 노출**시킨다는 점이다. Base64 인코딩은 안전하게 전송하기 위한 수단일 뿐, 보안은 적용되어 있지 않다. 따라서 이러한 상황에서는 HTTPS 통신이 필수적이다.

![HTTP 인증](https://developer.mozilla.org/ko/docs/Web/HTTP/Authentication/http-auth-sequence-diagram.png){: style="background-color:white" width="972" height="589" }
_출처 : <https://developer.mozilla.org/ko/docs/Web/HTTP/Authentication>_

HTTP는 무상태성을 가지므로, 현재의 요청은 과거의 요청과는 상관없이 독립적이다.  
이는 서비스 이용시 매 요청마다 자격증명을 보내 인증을 받아야한다는 것을 뜻한다.  
전송받은 자격증명은 DB와 연결하여 일치여부를 확인하게 되는데, 그렇다면 인증 요청이 늘어날 때 DB에 부하가 늘어날 것이다.  

우리의 서버는 여러 도메인별로 나뉘어져있어 각 서버가 다른 서버와 요청을 하기 위해서 인증을 받아야만한다. 
하나의 요청이 n개의 서비스를 이용한다고 가정하면, 동일한 인증을 n번을 받아야하는 것이다.  
그렇다면 한 서비스가 m번의 요청을 한다하면 동일한 인증을 **(n X m)**번 처리해야만 한다.

이러한 문제를 해결하기위해 서버가 상태를 가지게 하여 DB에 접근할 필요없고 빠르게 검증이 가능하다.
이러한 방식으로 세션 기반 인증이 있다. 세션은 서버의 메모리를 이용하는 것이다.
서버에 자격증명들을 미리 가져와놓고 인증 요청시 이와 비교해서 빠르게 인증 처리를 하는 것이다.

그렇지만, 서버가 자격증명을 가지고 있는 것은 매우 위험하다. 자격증명이 곧 개인정보와 연결되기 때문이다.
그러면 자격증명을 대체할 수 있는 방식이 필요하다. 이를 위해 **토큰 기반 인증**이 있다.
자격증명을 토큰으로 대체하여 처음 한번만 DB에 접속하여 토큰을 발급하고, 
그 이후로는 서버가 가진 토큰과 클라이언트에서 보내온 토큰을 비교하여 인증을 진행한다.
이러한 인증에 쓰이는 토큰으로는 SAML, SWT, JWT 등이 있다. 

SAML(Security Assertion Markup Language) 
: 인증 요청과 응답, 메타데이터 등으로 구성되어있는 XML 토큰이다.  

SWT(Simple Web Token)
: 키와 값 쌍으로 이뤄져있고 대칭키 알고리즘으로만 서명되는 가장 단순한 토큰이다.    

JWT(Json Web Token)
: JSON 구조를 가지며 대칭키 또는 비대칭키 알고리즘으로도 서명될 수 있는 토큰이다.


## 스케일 이슈
---
토큰 기반 인증을 통해 DB 접근을 최소화 시켰고, 자격증명 이슈도 해결했다.
하지만 세션 기반 인증과 토큰 기반 인증은 서버가 상태를 가지기에 한계를 지닌다.
만약 사용자가 100만명이면 100만명의 토큰을 가지고 있어야하기 때문이다.
또한 토큰을 저장하는 서버가 여러대가 될 경우에는 동기화 문제까지 발생한다.

[전자 서명](https://ko.wikipedia.org/wiki/%EB%94%94%EC%A7%80%ED%84%B8_%EC%84%9C%EB%AA%85)을 통해 이 문제를 해결할 수 있다.
전자 서명은 서버가 가진 키를 통해 토큰을 검증할 수 있게 한다. 서버는 토큰들을 전부 가질 필요없이 토큰에 대한 키만 가지고 있으면 된다.
또한 토큰이 변조되거나 위조된 토큰이면 서버가 가진 키를 이용하여 쉽게 검증하다.

언급한 토큰 중에서 JWT는 다른 토큰에 비해 간략하며 확장성이 높다. SAML은 XML로 작성되며 주로 여러개의 애플리케이션이 하나의 인증 방식으로 통합하는 SSO에 쓰인다. SWT는 정해진 표준이 없어 잘 사용되지 않는다. 그에 비해 JWT는 SAML에 비해 간략하여 통신에서 유리하고, 여러 암호화 방식, 여러 언어 환경에서도 지원하여 충분한 확장성을 가지고 있다.   

따라서 도메인 추가시에 늘어나는 서버에도 인증을 적용하기 위해서 JWT를 사용하는 것이 맞아보인다.


## JWT
---
JWT는 `{헤더}.{페이로드}.{시그니처}`로 이뤄져있다.   
**헤더**에는 `토큰의 타입과 알고리즘에 관한 메타데이터`가 담기며,   
**페이로드**에는 `실제 전송하는 데이터`를,   
**시그니처**에는 `모두 Base64로 인코딩된 헤더와 페이로드를 시크릿키와 함께 해쉬 함수를 적용시킨 값`이 들어간다. 이 때 해쉬 함수는 헤더에 지정된 알고리즘으로 정해진다.
```javascript
// 헤더
{
  "alg": "HS256",
  "typ": "JWT"
}
// ------------------
// 페이로드
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
// ------------------
```
위와 같은 JWT는 Base64로 인코딩되어 아래와 같이 변하게 된다.
![생성된 JWT](https://cdn2.auth0.com/content/jwt/encoded-jwt4.png){: style="background-color:white" width="972" height="589" }
_생성된 JWT | 출처 : <https://jwt.io/introduction/>_

만약 변조∙위조된 토큰이나, 다른 서버에서 발급된 토큰이 들어온다면,  
토큰의 헤더와 페이로드를 시크릿키와 함께 해싱한 뒤, 그 값이 현재 들어온 토큰의 시그니처값과 동일한 지를 판별하면 된다.  
만약 제대로된 토큰이라면 이 값이 일치할 것이고, 그렇지 않다면 다를 것이므로 쉽게 검증이 가능하다.    

이로써 토큰 생성 시크릿키만 알면 **서버가 토큰을 가지고 있을 필요없이 인증 처리**가 가능해지므로, **스케일 이슈를 해결**할 수 있다.
또한 시크릿키만 각 서버가 알면 검증이 가능하므로 **동기화 문제도 해결**할 수 있다.

## 보안 이슈
---
토큰을 사용자가 잘 보관한다면 앞선 문제들이 해결되고 별다른 문제가 없어보인다. 하지만 토큰이 자격증명을 대체하는 수단이 되었기에,
이 토큰을 사용자가 탈취당했을 경우 문제가 발생한다.

만약 토큰을 탈취당했다면, 서버는 토큰 검증만 하기에 토큰의 주인과 탈취자를 구분하지 못하게 된다.
그러면 탈취자가 계속 실제 토큰의 주인인 것처럼 서비스를 이용할 수 있다. 이러한 경우를 막을 수 없어보인다.
이미 토큰이 자격증명을 대체했기 때문이다.

그렇지만, 탈취한 토큰을 사용하는데에 제한할 수 있다. 바로, 토큰에 짧은 제한시간을 두는 것이다. 
토큰에 제한시간을 둠으로써 탈취한 토큰이 시간이 지나면 무효화된다.
하지만 토큰의 제한시간은 사용자 본인에게도 동일하게 적용되기에, 잦은 토큰 발급을 하게 만든다.
잦은 토큰 발급은 자격증명을 자주 전송하게 된다는 것을 뜻한다.  

자격증명을 자주 전송하는 것은 역시나 위험하다. ~~손을 자주 넣었다 뺐다하는 주머니에 있는 물건은 쉽게 사라지지 않던가~~

토큰을 발급받을 때 토큰 재발급만을 위한, 제한시간이 긴 토큰을 같이 발급해주자.
이 토큰이 있으면 자격증명을 전송할 필요없이 제한시간이 갱신된 토큰을 발급받게 된다.



### 참고자료
- 스프링 시큐리티 인 액션, 로렌티우 스필카
- React.js, 스프링 부트, AWS로 배우는 웹 개발 101 , 김다정
- [HTTP에서 Basic 인증 스펙](https://datatracker.ietf.org/doc/html/rfc7617)  
- [JWT 공식문서](https://jwt.io/introduction/)      
- [SAML(Security Assertion Markup Language)이란?](https://learn.microsoft.com/en-us/entra/architecture/auth-saml)
- [SWT와 JWT 비교글](https://www.networknt.com/architecture/swt-vs-jwt/)