---
layout: post
title: 일반화와 추상화
date: 2024-07-01 19:52 +0900
description: 일반화와 추상화 용어 정리글
category: [컴퓨터과학, Terminology] 
tags: [일반화, 추상화, 용어 정리]
---

CS 관련 도서를 읽을 때면 일반화라는 말과 추상화라는 말을 자주 접한다. 이전까지는 두 말의 의미를 “핵심적인 것만 본다” 정도로 이해했으나 두 의미는 비슷하면서도 달랐다. 또 어떤 개념을 일반화한다는 말이 나오면 이유는 모르겠으나 계속 눈에 밟혔다. 그래서 두 용어를 이번에 확실히 정리해 보려 한다.

## 일반화(Generalization)
---
일반화는 **특정 사례들의 공통되는 속성들을 일반적인 개념이나 주장으로 공식화하는 추상화의 한 형태**이다. [위키백과](https://ko.wikipedia.org/wiki/%EC%9D%BC%EB%B0%98%ED%99%94)에 따르면 A가 B의 일반화 개념이라면 "개념 B의 모든 사례가 개념 A의 한 사례이다."와 "개념 A의 사례 중 개념 B의 사례가 아닌 사례가 있어야 한다"라고 한다. 그렇다면 일반화는 어떤 개념의 상위 개념을 찾는 것으로 보인다.  

> "B-트리는 이진 검색 트리를 **일반화**한 것입니다"  
> \- _Introduction to Algorithm_

이것을 바꿔 말하자면 B-트리(**A**)가 이진 검색 트리(*B*)의 일반화 개념이다. 이진 검색 트리는 각 노드가 최대 두 개의 자식 노드를 가지는 트리 구조이다. 반면 B-트리는 각 노드가 더 많은 자식 노드를 가질 수 있는 트리 구조로, 둘 다 검색을 목적으로 하는 자료구조이다.  

모든 이진 검색 트리는 노드의 개수가 2개이고 B-트리는 3개 이상 노드를 가질 수도 있고, 2개를 가질 수도 있으니 B-트리는 이진 검색 트리의 일반화 개념으로 볼 수 있겠다.

또 다른 예로 가상 메모리 관리 기법 중 **세그멘테이션(Segmentation) 기법**이 있다.
> "세그멘테이션은 베이스와 바운드 기법을 **일반화**한 것이다."  
> \- _Operating System: Three Easy Piece_

**베이스와 바운드 기법**에서 베이스와 바운드는 둘 다 레지스터이며, 베이스는 프로세스의 시작 주소, 바운드에는 프로세스 크기가 담긴다. 세그멘테이션은 메모리 영역을 나누고 **세그멘트**(Segment)로써 관리한다. 세그멘트는 특정 길이를 가지는 연속적인 주소 공간을 말한다. 세그멘테이션에도 베이스와 바운드가 존재하고 더 작고 공통적인 개념인 세그멘트로 다루기에 베이스와 바운드 기법의 상위 개념으로써 일반화된 게 맞다.

그런데 걸리는 것이 있다. 세그멘테이션은 베이스와 바운드 기법의 일반화 개념이다. 이에 따라 "개념 A의 사례 중 개념 B의 사례가 아닌 사례가 있어야 한다"에 적용해 보면, 세그멘테이션의 사례 중 베이스와 바운드 기법의 사례가 아닌 사례가 있어야 한다. 하지만 세그멘테이션의 모든 사례는 베이스 바운드 기법을 포함할 수밖에 없다.  

이렇게 된다면, 반대가 맞지 않을까 싶은 생각이다. 세그멘테이션을 일반화한 것이 베이스 바운드 기법이라면, 베이스 바운드 기법이 세그멘테이션의 일반화 개념이라고 한다면 다 들어맞는다. 베이스 바운드 기법은 하드웨어와 소프트웨어에서 메모리를 다루는 여러 사례에서 쓰이고 세그멘테이션은 소프트웨어에서만 쓰이니 첫 번째 조건에도 들어맞는다. 

## 추상화(Abstraction)
---
추상화는 **복잡한 시스템을 단순화하여 중요한 개념이나 기능만을 남기는 것**을 의미한다. 이는 한마디로 핵심을 간추려내는 것이라 볼 수 있다. 추상화를 통해 불필요한 세부 사항을 숨기고, 시스템의 핵심적인 부분에 집중할 수 있다.

> "추상화의 사용은 전산학에서 가장 중요한 개념이다."  
> "파일은 입출력 장치의 추상화, 가상메모리는 메인 메모리와 디스크의 추상화, 프로세스는 프로세서, 메인 메모리, 입출력 장치의 추상화다."   
> \- _Computer System: A Programmer's Perspective_

입출력 장치에는 키보드, 마우스, 모니터, 네트워크 소켓, 프린터 따위가 있다. 이것들을 프로그래머가 사용하려면 각 장치별로 다르게 사용 방식을 알아야 하는데 이는 입출력 장치 사용을 매우 복잡하게 만든다. 만약, 하나의 일관된 인터페이스로 제공해 준다면 훨씬 더 단순하게 프로그래밍이 가능할 것이다. 그리하여 운영체제에서는 이러한 입출력 장치를 **파일로 추상화**시켜 놓았다.  

이를 통해 모니터에 문자를 출력하는 것과 네트워크로 문자를 보내는 것을 동일한 인터페이스로 제공할 수 있다. 장치들은 **파일**이라는 하나의 형태로 제공되어 이 파일에 **write**와 같은 동일한 연산으로 실제 데이터를 전송할 수 있게 된다. write 연산을 하게 되면 데이터는 모니터 출력은 콘솔 파일로, 네트워크 전송은 소켓 파일로 전달되어 처리될 것이다. 처리 과정에서 입력을 받아 처리하는 방식은 다르지만 추상화를 통해 **목적지(파일)와 연산**에만 집중할 수 있게 됐다.

**프로그래밍**에서도 추상화를 발견할 수 있다. 쉬운 예로 Java에서 객체를 할당하는데 new 키워드를 사용한다. new 키워드를 통해 특정 크기의 메모리를 힙에 할당받아 사용할 수 있다. 하지만 프로그래머가 사용할 때 어느 곳에 할당되는지, 어떻게 물리 메모리가 할당되는 지에 대한 세부 사항은 몰라도 된다. 단순하게 new 키워드만 알면 메모리를 사용할 수 있으며 나아가 프로그램을 개발할 수 있다.

**네트워크 계층**도 추상화와 캡슐화로 이뤄진 구조이다. 가장 위인 응용 계층에서의 동작은 실제 물리 계층에서 일어나는 비트 전송과 같은 하위 계층에서 일어나는 동작을 숨겨, 각 프로토콜에 맞춰서 통신하는 데에만 집중할 수 있다. 이렇듯 추상화는 많은 개념에서 쓰이고 있다.

## 마무리
---
일반화와 추상화는 서로 비슷한 개념을 띄고 있는 것 같았으나 핵심적인 의미는 달랐다. 일반화는 더 넓은 범위에 적용할 수 있는 개념이나 원리를 도출하는 데 초점을 맞추지만, 추상화는 복잡한 시스템이나 개념을 더 단순하고 이해하기 쉬운 형태로 표현하는 데 초점을 맞춘다.

예전에 기술 용어에 민감하신 분을 만나고 난 뒤부터 용어 사용에 조금 더 조심하게 됐다. 그런 분에게 잘못된 용어는 마치 그분의 머릿속을 헤집어 놓는 것만 같았다. 만약 그런 분을 만난다면 애매한 기술 용어를 말하기보다는 오히려 풀어서 설명하는 게 대화를 이어 나가는 데 도움이 될 것 같다.
