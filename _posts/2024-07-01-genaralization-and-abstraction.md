---
layout: post
title: Genaralization and Abstraction
date: 2024-07-01 19:52 +0900
description: 일반화와 추상화
category: [컴퓨터과학, Terminology] 
tags: [일반화, 추상화, 용어 정리]
---

CS 관련 도서를 읽을 때면 일반화라는 말과 추상화라는 말을 자주 접한다.이전까지는 두 말의 의미를 “핵심적인 것만 본다” 정도로 이해했으나 두 의미는 비슷하면서도 달랐다. 또 어떤 개념을 일반화한다라는 말이 나오면 이유는 모르겠으나 계속 눈에 밟혔다. 그래서 두 용어를 이번에 확실히 정리해보려 한다.

# 일반화(Generalization)
---
일반화는 특정 사례들의 공통되는 속성들을 일반적인 개념이나 주장으로 공식화하는 추상화의 한 형태이다. [위키백과](https://ko.wikipedia.org/wiki/%EC%9D%BC%EB%B0%98%ED%99%94)에 따르면 A가 B의 일반화 개념이려면 "개념 B의 모든 사례가 개념 A의 한 사례이다."와 "개념 A의 사례 중 개념 B의 사례가 아닌 사례가 있어야 한다"라고 한다. 그렇다면 일반화는 어떤 개념의 상위 개념을 찾는 것으로 보인다.  

> "B-트리는 이진 검색 트리를 **일반화**한 것입니다"  
> \- _Introduction to Algorithm_

이것을 바꿔 말하자면 B-트리(**A**)가 이진 검색 트리(*B*)의 일반화 개념이다. 이진 검색 트리는 각 노드가 최대 두 개의 자식 노드를 가지는 트리 구조이다. 반면 B-트리는 각 노드가 더 많은 자식 노드를 가질 수 있는 트리 구조로, 둘 다 검색을 목적으로 하는 자료구조이다.  

모든 이진 검색 트리는 노드의 갯수가 2개이고 B-트리는 3개 이상 노드를 가질 수도 있고, 2개를 가지는 경우도 있으니 B-트리는 이진 검색 트리의 일반화 개념으로 볼 수 있겠다.

또 다른 예로 가상 메모리 관리 기법 중 세그멘테이션(Segmentation) 기법이 있다.
> "세그멘테이션은 베이스와 바운드 기법을 **일반화**한 것이다."  
> \- _Operating System: Three Easy Piece_

베이스와 바운드 기법에서 베이스와 바운드는 둘 다 레지스터이며, 베이스는 프로세스의 시작 주소, 바운드에는 프로세스 크기가 담긴다. 세그멘테이션은 메모리 영역을 나누고 **세그멘트**(Segment)로써 관리한다. 세그멘트는 특정 길이를 가지는 연속적인 주소 공간을 말한다. 세그멘테이션에도 베이스와 바운드가 존재하고 더 작고 공통적인 개념인 세그멘트로 다루기에 베이스와 바운드 기법의 상위 개념으로써 일반화된 게 맞다.

그런데 걸리는 것이 있다. 세그멘테이션은 베이스와 바운드 기법의 일반화 개념이다. 이에 따라 "개념 A의 사례 중 개념 B의 사례가 아닌 사례가 있어야 한다"에 적용해 보면, 세그멘테이션의 사례 중 베이스와 바운드 기법의 사례가 아닌 사례가 있어야 한다. 하지만 세그멘테이션의 모든 사례는 베이스 바운드 기법을 포함할 수밖에 없다.  

이렇게 된다면, 반대가 맞지 않을까 싶은 생각이다. 세그멘테이션을 일반화한 것이 베이스 바운드 기법이라면, 베이스 바운드 기법이 세그멘테이션의 일반화 개념이라고 한다면 다 들어맞는다. 베이스 바운드 기법은 하드웨어와 소프트웨어에서 메모리를 다루는 여러 사례에서 쓰이고 세그멘테이션은 소프트웨어에서만 쓰이니 첫 번째 조건에도 들어맞는다. 

# 추상화(Abstraction)
---
추상화는 복잡한 시스템을 단순화하여 중요한 개념이나 기능만을 남기는 것을 의미한다. 이는 한마디로 핵심을 간추려내는 것이라 볼 수 있다. 추상화를 통해 불필요한 세부 사항을 숨기고, 시스템의 핵심적인 부분에 집중할 수 있다.

> "추상화의 사용은 전산학에서 가장 중요한 개념이다."  
> "파일은 입출력 장치의 추상화, 가상메모리는 메인 메모리와 디스크의 추상화, 프로세스는 프로세서, 메인 메모리, 입출력 장치의 추상화다."   
> \- _Computer System: A Programmer's Perspective_

입출력 장치에는 키보드, 마우스, 모니터, 네트워크 소켓, 프린터 따위가 있다.  
이것들을 프로그래머가 사용하려면 각 장치별로 다르게 사용방식을 알아야하는데 이는 입출력 장치 사용을 매우 복잡하게 만든다. 만약, 하나의 일관된 인터페이스로 제공해준다면 훨씬 더 단순하게 프로그래밍이 가능할 것이다. 그리하여 운영체제에서는 이러한 입출력 장치를 파일로 추상화시켜놓았다.  

모니터에 문자를 출력하는 것과 네트워크로 문자를 보내는 것을 동일한 인터페이스로 제공한다는 것이다. 입출력 연산에서 장치에 따라 다른 동작과 같은 불필요한 세부 사항을 숨기고, write와 같은 핵심적인 연산으로 추상화시켜면서 가능했다. 

프로그래밍에서도 추상화를 발견할 수 있다. 쉬운 예로 Java에서 객체를 할당하는데 new 키워드를 사용한다. new 키워드를 통해 특정 크기의 메모리를 힙에 할당받아 사용할 수 있다. 하지만 프로그래머가 사용할 때 어느 곳에 할당되는 지, 어떻게 물리 메모리가 할당되는 지에 대한 세부 사항은 몰라도 된다. 단순하게 new 키워드만 알면 메모리를 사용할 수 있으며 나아가 프로그램을 개발할 수 있다.

네트워크 계층도 추상화와 캡슐화로 이뤄진 구조이다. 가장 위인 응용 계층에서의 동작은 실제 물리 계층에서 일어나는 비트 전송과 같은 하위 계층에서 일어나는 동작들을 숨겨, 각 프로토콜에 맞춰서 통신하는데에만 집중할 수 있다.

# 일반화와 추상화의 차이점
---
일반화와 추상화는 모두 시스템을 단순화하고 이해하기 쉽게 만드는 데 도움이 되지만, 그 접근 방식과 목적이 다르다.
* 일반화는 여러 구체적인 사례에서 공통적인 요소를 찾아내어 하나의 일반적인 모델로 확장하는 것이다. 이는 다양한 사례를 하나의 통일된 구조로 만들 때 유용하다.
* 추상화는 복잡한 시스템에서 중요한 개념이나 기능만을 강조하여 불필요한 세부 사항을 숨기는 것이다. 이는 시스템의 핵심적인 부분에 집중하고, 이를 쉽게 이해하고 사용할 수 있도록 한다.

일반화는 더 넓은 범위에 적용할 수 있는 개념이나 원리를 도출하는 데 초점을 맞추는 반면, 추상화는 복잡한 시스템이나 개념을 더 단순하고 이해하기 쉬운 형태로 표현하는 데 초점을 맞춘다.

# 마무리
용어 오용시 문제점.
만난 사람들.
주의 사항 환기.


